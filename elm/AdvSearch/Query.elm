module AdvSearch.Query exposing (..)

import Set
import Json.Encode as JE
import Json.Decode as JD

-- Generic dynamically typed representation of a query.
-- Used only as an intermediate format to help with encoding/decoding.
type Op = Eq | Ne | Ge | Le
type Query
  = QAnd (List Query)
  | QOr (List Query)
  | QInt String Op Int
  | QStr String Op String
  | QQuery String Op Query


encodeOp : Op -> JE.Value
encodeOp o = JE.string <|
  case o of
    Eq -> "="
    Ne -> "!="
    Ge -> ">="
    Le -> "<="

encodeQuery : Query -> JE.Value
encodeQuery q =
  case q of
    QAnd l -> JE.list identity (JE.string "and" :: List.map encodeQuery l)
    QOr  l -> JE.list identity (JE.string "or"  :: List.map encodeQuery l)
    QInt   s o a -> JE.list identity [JE.string s, encodeOp o, JE.int a]
    QStr   s o a -> JE.list identity [JE.string s, encodeOp o, JE.string a]
    QQuery s o a -> JE.list identity [JE.string s, encodeOp o, encodeQuery a]



-- Drops the first item in the list, decodes the rest
decodeQList : JD.Decoder (List Query)
decodeQList =
  let dec l = List.map (JD.decodeValue decodeQuery) (List.drop 1 l) -- [Result Query]
      f v r = Result.andThen (\a -> Result.map (\e -> (e::a)) v) r -- Result Query -> Result [Query] -> Result [Query]
      res l = case List.foldr f (Ok []) (dec l) of  -- Decoder [Query]
                Err e -> JD.fail (JD.errorToString e)
                Ok v  -> JD.succeed v
  in JD.list JD.value |> JD.andThen res -- [Value]

decodeOp : JD.Decoder Op
decodeOp = JD.string |> JD.andThen (\s ->
  case s of
    "="  -> JD.succeed Eq
    "!=" -> JD.succeed Ne
    ">=" -> JD.succeed Ge
    "<=" -> JD.succeed Le
    _    -> JD.fail "Invalid operator")

decodeQuery : JD.Decoder Query
decodeQuery = JD.index 0 JD.string |> JD.andThen (\s ->
   case s of
     "and" -> JD.map QAnd decodeQList
     "or"  -> JD.map QOr decodeQList
     _ -> JD.oneOf
      [ JD.map2 (QInt s  ) (JD.index 1 decodeOp) (JD.index 2 JD.int)
      , JD.map2 (QStr s  ) (JD.index 1 decodeOp) (JD.index 2 JD.string)
      , JD.map2 (QQuery s) (JD.index 1 decodeOp) (JD.index 2 decodeQuery)
      ]
   )




-- Helper functions for Set-like filters

type alias SetModel a =
  { sel    : Set.Set a
  , single : Bool
  , and    : Bool
  , neg    : Bool
  , last   : Set.Set a -- Last selection before switching to single mode, if there were multiple items selected
  }

type SetMsg a
  = SetSel a Bool
  | SetNeg Bool
  | SetAnd Bool
  | SetMode -- Toggle between single / multi (or) / multi (and)


setInit : SetModel a
setInit = { sel = Set.empty, single = True, and = False, neg = False, last = Set.empty }


setUpdate : SetMsg comparable -> SetModel comparable -> SetModel comparable
setUpdate msg model =
  case msg of
    SetSel v b -> { model | last = Set.empty, sel = if not b then Set.remove v model.sel else if model.single then Set.fromList [v] else Set.insert v model.sel }
    SetNeg b   -> { model | neg = b }
    SetAnd b   -> { model | and = b }
    SetMode    ->
      let m = { model | single = not model.single && model.and, and = not model.single && not model.and }
      in  { m | sel = if m.single then Set.fromList <| List.take 1 <| Set.toList m.sel
                      else if model.single && not m.single && not (Set.isEmpty model.last) then m.last
                      else m.sel
              , last = if m.single && not model.single && Set.size m.sel > 1 then m.sel else Set.empty }


-- Usage: setToQuery (QStr "lang") model
setToQuery : (Op -> a -> Query) -> SetModel a -> Maybe Query
setToQuery f m =
  case (m.neg, m.and, Set.toList m.sel) of
    (_,_,[])  -> Nothing
    (n,_,[v]) -> Just (f (if n then Ne else Eq) v)
    (False, False, l) -> Just <| QOr  <| List.map (\v -> f Eq v) l
    (True , False, l) -> Just <| QAnd <| List.map (\v -> f Ne v) l
    (False, True , l) -> Just <| QAnd <| List.map (\v -> f Eq v) l
    (True , True , l) -> Just <| QOr  <| List.map (\v -> f Ne v) l


-- Only recognizes queries generated by setToQuery, doesn't handle alternative query structures.
-- Usage:
--   setFromQuery (\q -> case q of
--                         QStr "lang" op v -> Just (op, v)
--                         _ -> Nothing) model
setFromQuery : (Query -> Maybe (Op,comparable)) -> Query -> Maybe (SetModel comparable)
setFromQuery f q =
  let single and qs = f qs |> Maybe.andThen (\(op,v) ->
        if op /= Ne && op /= Eq
        then Nothing
        else Just { sel = Set.fromList [v], and = xor and (op == Ne), neg = (op == Ne), single = True, last = Set.empty })
      lst mm xqs =
        case (mm, xqs) of
          (Nothing, _) -> Nothing
          (_, [])      -> mm
          (Just m, x :: xs) -> f x |> Maybe.andThen (\(op,v) ->
            if (op /= Ne && op /= Eq) || (op == Ne) /= m.neg
            then Nothing
            else lst (Just {m | single = False, sel = Set.insert v m.sel}) xs)
  in case q of
      QAnd (x::xs) -> lst (single True  x) xs
      QOr  (x::xs) -> lst (single False x) xs
      _ -> single False q
