module AdvSearch.Set exposing (..)

import Html exposing (..)
import Html.Attributes exposing (..)
import Set
import Lib.Html exposing (..)
import Lib.Util exposing (..)
import Gen.Types as GT
import AdvSearch.Query exposing (..)


type alias Model a =
  { sel    : Set.Set a
  , single : Bool
  , and    : Bool
  , neg    : Bool
  , last   : Set.Set a -- Last selection before switching to single mode, if there were multiple items selected
  }

type Msg a
  = Sel a Bool
  | Neg Bool
  | And Bool
  | Single Bool
  | Mode -- Toggle between single / multi (or) / multi (and)


init : Data -> (Data, Model a)
init dat = (dat, { sel = Set.empty, single = True, and = False, neg = False, last = Set.empty })


update : Msg comparable -> Model comparable -> Model comparable
update msg model =
  let singleMode m =
        { m | sel = if m.single then Set.fromList <| List.take 1 <| Set.toList m.sel
                    else if model.single && not m.single && not (Set.isEmpty model.last) then m.last
                    else m.sel
            , last = if m.single && not model.single && Set.size m.sel > 1 then m.sel else Set.empty }
  in
  case msg of
    Sel v b  -> { model | last = Set.empty, sel = if not b then Set.remove v model.sel else if model.single then Set.fromList [v] else Set.insert v model.sel }
    Neg b    -> { model | neg = b }
    And b    -> { model | and = b }
    Single b -> singleMode { model | single = b }
    Mode     -> singleMode { model | single = not model.single && model.and, and = not model.single && not model.and }


toQuery : (Op -> a -> Query) -> Model a -> Maybe Query
toQuery f m =
  case (m.neg, m.and, Set.toList m.sel) of
    (_,_,[])  -> Nothing
    (n,_,[v]) -> Just (f (if n then Ne else Eq) v)
    (False, False, l) -> Just <| QOr  <| List.map (\v -> f Eq v) l
    (True , False, l) -> Just <| QAnd <| List.map (\v -> f Ne v) l
    (False, True , l) -> Just <| QAnd <| List.map (\v -> f Eq v) l
    (True , True , l) -> Just <| QOr  <| List.map (\v -> f Ne v) l


-- Only recognizes queries generated by setToQuery, doesn't handle alternative query structures.
-- Usage:
--   setFromQuery (\q -> case q of
--                         QStr 2 op v -> Just (op, v)
--                         _ -> Nothing) model
fromQuery : (Query -> Maybe (Op,comparable)) -> Data -> Query -> Maybe (Data, Model comparable)
fromQuery f dat q =
  let single and qs = f qs |> Maybe.andThen (\(op,v) ->
        if op /= Ne && op /= Eq
        then Nothing
        else Just (dat, { sel = Set.fromList [v], and = xor and (op == Ne), neg = (op == Ne), single = True, last = Set.empty }))
      lst mm xqs =
        case (mm, xqs) of
          (Nothing, _) -> Nothing
          (_, [])      -> mm
          (Just (_,m), x :: xs) -> f x |> Maybe.andThen (\(op,v) ->
            if (op /= Ne && op /= Eq) || (op == Ne) /= m.neg
            then Nothing
            else lst (Just (dat, {m | single = False, sel = Set.insert v m.sel})) xs)
  in case q of
      QAnd (x::xs) -> lst (single True  x) xs
      QOr  (x::xs) -> lst (single False x) xs
      _ -> single False q


lblPrefix m = text <| (if m.neg then "¬" else "") ++ (if m.single || Set.size m.sel == 1 then "" else if m.and then "∀ " else "∃ ")


opts m canAnd canSingle = div [ class "opts" ]
  [ a
    [ href "#"
    , onClickD (if canAnd && canSingle then Mode else if canSingle then Single (not m.single) else And (not m.and))
    , title <| if m.single then "Single-selection mode" else if m.and then "Entry must match all selected items" else "Entry must match at least one item"
    ] [ text <| "Mode:" ++ if m.single then "single" else if m.and then "all" else "any" ]
  , linkRadio m.neg Neg [ text "invert" ]
  ]




-- Language

langView orig model =
  let tprefix = if orig then "O " else "L "
  in
  ( case Set.toList model.sel of
      []  -> b [ class "grayedout" ] [ text <| if orig then "Orig language" else "Language" ]
      [v] -> span [ class "nowrap" ] [ text tprefix, lblPrefix model, langIcon v, text <| Maybe.withDefault "" (lookup v GT.languages) ]
      l   -> span [ class "nowrap" ] <| text tprefix :: lblPrefix model :: List.intersperse (text "") (List.map langIcon l)
  , \() ->
    [ div [ class "advheader" ]
      [ h3 [] [ text <| if orig then "Language the visual novel has been originally written in." else "Language(s) in which the visual novel is available." ]
      , opts model (not orig) True
      ]
    , ul [ style "columns" "2"] <| List.map (\(l,t) -> li [] [ linkRadio (Set.member l model.sel) (Sel l) [ langIcon l, text t ] ]) GT.languages
    ]
  )

langFromQuery = fromQuery (\q ->
  case q of
    QStr 2 op v -> Just (op, v)
    _ -> Nothing)

olangFromQuery = fromQuery (\q ->
  case q of
    QStr 3 op v -> Just (op, v)
    _ -> Nothing)




-- Platform

platformView model =
  ( case Set.toList model.sel of
      []  -> b [ class "grayedout" ] [ text "Platform" ]
      [v] -> span [ class "nowrap" ] [ lblPrefix model, platformIcon v, text <| Maybe.withDefault "" (lookup v GT.platforms) ]
      l   -> span [ class "nowrap" ] <| lblPrefix model :: List.intersperse (text "") (List.map langIcon l)
  , \() ->
    [ div [ class "advheader" ]
      [ h3 [] [ text "Platforms for which the visual novel is available." ]
      , opts model True True
      ]
    , ul [ style "columns" "2"] <| List.map (\(p,t) ->
        li [classList [("separator", p == "web")]] [ linkRadio (Set.member p model.sel) (Sel p) [ platformIcon p, text t ] ]
      ) GT.platforms
    ]
  )

platformFromQuery = fromQuery (\q ->
  case q of
    QStr 4 op v -> Just (op, v)
    _ -> Nothing)




-- Length

lengthView model =
  ( case Set.toList model.sel of
      []  -> b [ class "grayedout" ] [ text "Length" ]
      [v] -> span [ class "nowrap" ] [ lblPrefix model, text <| Maybe.withDefault "" (lookup v GT.vnLengths) ]
      l   -> span [] [ lblPrefix model, text <| "Length (" ++ String.fromInt (List.length l) ++ ")" ]
  , \() ->
    [ div [ class "advheader" ]
      [ h3 [] [ text "Length (estimated play time)" ]
      , opts model False True ]
    , ul [] <| List.map (\(l,t) -> li [] [ linkRadio (Set.member l model.sel) (Sel l) [ text t ] ]) GT.vnLengths
    ]
  )

lengthFromQuery = fromQuery (\q ->
  case q of
    QInt 5 op v -> Just (op, v)
    _ -> Nothing)
